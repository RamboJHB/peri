===========================================
Compte Rendu PERI TP6:Programmation Arduino
===========================================

| Dans cette séance on a le but de faire la programmation sur Arduino. On a étudié que un programme Arduino est composé au minimum de 2 fonctions:

| - setup() exécutée une fois pour initialiser les composants et les variables.

| - loop() exécutée en boucle jusqu'à l'extinction de la carte.

| Parce qu'il n'y a pas de système d'exploitation sur la carte Arduino, lorsqu'on veut expérimenter la programmation "multi-tâches",les "tâches" seront programmées de sorte à être indépendantes de leur contexte d'utilisation et elles seront "ordonnancées" par la fonction loop(). La fonction loop() demande donc l'exécution des tâches à tour de rôle. Les tâches n'ont pas le droit de conserver le processeur sinon cela crée un blocage du système.

| **Question:**

| **Que contient le tableau waitForTimer[]` ?**

| Le numéro de période enregistré. (en microseconde)

**Dans quel cas la fonction `waitFor() peut rendre 2 ?**

| La fonction waitFor() rend le nombre de période écoulée depuis le dernier appel, elle rend 1 chaque période, est elle est de la valeur 0 pendant la durée d'une période. C'est possible que le numéro de période arrive à la fin de la chronologie et il repasse au début, mais le vieil numéro de période est enregistré,dans ce cas la fonction va rendre la valeur 2.


**Quel est le numéro de l'abonné I2C de l'écran ?**

| Un abonné I2C dispose d'une adresse sur le bus (numéro d'abonné). Dans le cas général un abonné contient de la mémoire adressable.


**Modifier le programme initial pour afficher "bonjour" sur l'Oled toutes les 2 secondes sans changer le comportement existant.**

| En haut on ajoute:
| *static int lin = 0;*

| Et puis on modifie la fonction Mess():
|
| void Mess(int timer, long period, const char * mess) {
|   if (!(waitFor(timer, period))) return;                   
|   display.setTextSize(2);
|   display.setTextColor(WHITE);
|   if (lin == 0) lin = 1;
|   else  lin = 0;
|   display.println(mess);
|   display.display();                                   
| }

| Ensuite on voudrais expérimenter la communications inter-tâches. On a besoin d'une boite à lettre et une variable d'état à 2 valeur indiquant l'état de la boite. La boite peut être vide ou pleine. Chaque tâche ne peut écrire que lorsque la boite est vide. Lorsqu'elle est vide, il y écrit et il change l'état. Inversement, le lecteur attend qu'elle soit pleine. Lorsqu'elle est pleine, il la lit et change l'état. On modifie le code basé comme ci-dessous:

| enum etat {EMPTY, FULL};
| 
| struct mailbox {
|   etat state;
|   char val;
| } mb0 = {.state = EMPTY};
| 
| void T1(struct mailbox *mb) {
|   if (mb->state != EMPTY) return; // attend que la mailbox soit vide
|   mb->val = Serial.read();
|   mb->state = FULL;
| }
| 
| void T2(struct mailbox *mb) {
|   if (mb->state != FULL) return; // attend que la mailbox soit pleine
|   if ((mb->val == 'A') && (rd_ms == 0)) {
|     ledc = 1;
|   }
|   else if ((mb->val == 'E') && (rd_ms == 0)) {
|     ledc = 0;
|   }
|   else if ((mb->val == 'P') && (rd_ms == 0)) {
|     rd_ms = 1;
|     display.clearDisplay();
|     display.setTextSize(2);
|     display.setTextColor(WHITE);
|     display.setCursor(0, 0);
|   }
|   else if (rd_ms == 1) {
|     if (mb->val == ' ') {
|       rd_ms = 0;
|       str[len] = '\0';
|       display.print(str);
|       display.display();
|       len = 0;
|     }
|     else if(((mb->val>='a') && (mb->val <= 'z')) || ((mb->val>='A') && (mb->val <= 'Z')) || ((mb->val>='0') && (mb->val <= '9'))){
|       str[len] = mb->val;
|       ++len;
|     }
|   }
| 
|   mb->state = EMPTY;
| }
